

// Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// SuperStructureProjector.ScanLine
using UnityEngine;

public class ScanLine : SuperStructureProjectorPart
{
	public bool alignment;

	public float pos;

	public float lastPos;

	public float speed;

	public ScanLine(SuperStructureProjector projector, bool alignment, float pos, float dir)
		: base(projector)
	{
		projector.scanLines.Add(this);
		speed = Mathf.Lerp(1f, 7f, Random.value) * dir;
		this.alignment = alignment;
		this.pos = pos + Mathf.Sign(speed);
		lastPos = pos - Mathf.Sign(speed);
	}

	public override void Update(bool eu)
	{
		base.Update(eu);
		lastPos = pos;
		pos += speed;
		if (alignment)
		{
			pos += projector.gridPos.x - projector.lastGridPos.x;
			if ((pos < -200f && lastPos < -200f && speed < 0f) || (pos > room.PixelWidth + 200f && lastPos > room.PixelWidth + 200f && speed > 0f))
			{
				Destroy();
			}
		}
		else
		{
			pos += projector.gridPos.y - projector.lastGridPos.y;
			if ((pos < -200f && lastPos < -200f && speed < 0f) || (pos > room.PixelHeight + 200f && lastPos > room.PixelHeight + 200f && speed > 0f))
			{
				Destroy();
			}
		}
	}

	public override void InitiateSprites(RoomCamera.SpriteLeaser sLeaser, RoomCamera rCam)
	{
		sLeaser.sprites = new FSprite[2];
		for (int i = 0; i < 2; i++)
		{
			sLeaser.sprites[i] = new FSprite("pixel");
			if (projector.debugColor)
			{
				sLeaser.sprites[i].color = new Color(1f, 0f, 0f);
			}
			else
			{
				sLeaser.sprites[i].color = new Color(0f, 0f, 0f);
			}
			if (alignment)
			{
				sLeaser.sprites[i].scaleX = 2f;
				sLeaser.sprites[i].scaleY = 768f;
				sLeaser.sprites[i].anchorY = 0f;
			}
			else
			{
				sLeaser.sprites[i].scaleX = 1366f;
				sLeaser.sprites[i].scaleY = 2f;
				sLeaser.sprites[i].anchorX = 0f;
			}
		}
		AddToContainer(sLeaser, rCam, null);
	}

	public override void DrawSprites(RoomCamera.SpriteLeaser sLeaser, RoomCamera rCam, float timeStacker, Vector2 camPos)
	{
		for (int i = 0; i < sLeaser.sprites.Length; i++)
		{
			sLeaser.sprites[i].isVisible = projector.visible;
		}
		if (!projector.visible)
		{
			return;
		}
		if (alignment)
		{
			for (int j = 0; j < 2; j++)
			{
				sLeaser.sprites[j].x = Mathf.Lerp(lastPos, pos, timeStacker) - camPos.x + 15f * (float)j;
			}
		}
		else
		{
			for (int k = 0; k < 2; k++)
			{
				sLeaser.sprites[k].y = Mathf.Lerp(lastPos, pos, timeStacker) - camPos.y + 15f * (float)k;
			}
		}
		base.DrawSprites(sLeaser, rCam, timeStacker, camPos);
	}
}
